declare namespace corde {
  interface IMatchers<T extends any> {
    toBe(expected: T): void;
    toEqual(expected: T): void;
    toBeCloseTo(expected: T, precisionopt: number): void;
    toBeDefined(): void;
    toBeFalse(): void;
    toBeFalsy(): void;
    toBeGreaterThan(expected: number | bigint): void;
    toBeGreaterThanOrEqual(expected: number | bigint): void;
    toBeInstanceOf<U extends any>(expected: T | U): void;
    toBeLessThan(expected: number | bigint): void;
    toBeLessThanOrEqual(expected: number | bigint): void;
    toBeNaN(): void;
    toBeNegativeInfinity(): void;
    toBeNull(): void;
    toBeUndefined(): void;
    toBePositiveInfinity(): void;
    toBeTrue(): void;
    toBeTruthy(): void;
    toContain(expected: T): void;
    toHaveBeenCalled(): void;
    toHaveBeenCalledBefore(expected): void;
    toHaveBeenCalledOnceWith(): void;
    toHaveBeenCalledTimes(amount: number): void;
    toHaveBeenCalledWith(): void;
    toHaveClass(expected): void;
    toHaveSize(size: number): void;
    toMatch(expected): void;
    toThrow<U extends any>(expectedThrow: U): void;
    toThrowError<U extends Error>(expectedopt: U): void;
    toThrowMatching(predicate): void;
    any(constructor: any): void;
    anything(mixed: any): void;
    arrayContaining(mixed): void;
    objectContaining(mixed): void;
    stringMatching(pattern): void;
    toBeArrayOfBooleans(): void;
    toBeArrayOfNumbers(): void;
    toBeArrayOfObjects(): void;
    toBeArrayOfSize(number): void;
    toBeArrayOfStrings(): void;
    toBeEmptyArray(): void;
    toBeNonEmptyArray(): void;
    toBeAfter(otherDate: Date): void;
    toBeBefore(otherDate: Date): void;
    toBeDate(): void;
    toBeValidDate(): void;
    toBeFunction(): void;
    toThrowAnyError(): void;
    toThrowErrorOfType(constructorName): void;
    toBeCalculable(): void;
    toBeEvenNumber(): void;
    toBeGreaterThanOrEqualTo(otherNumber: number | bigint): void;
    toBeLessThanOrEqualTo(otherNumber: number | bigint): void;
    toBeNear(otherNumber: number | bigint, epsilon): void;
    toBeOddNumber(): void;
    toBeWholeNumber(): void;
    toBeWithinRange(floor, ceiling): void;
    toBeEmptyObject(): void;
    toBeNonEmptyObject(): void;
    toHaveArray(memberName): void;
    toHaveArrayOfBooleans(memberName): void;
    toHaveArrayOfNumbers(memberName): void;
    toHaveArrayOfObjects(memberName): void;
    toHaveArrayOfSize(memberName, size): void;
    toHaveArrayOfStrings(memberName): void;
    toHaveBoolean(memberName): void;
    toHaveCalculable(memberName): void;
    toHaveDate(memberName): void;
    toHaveDateAfter(memberName, date): void;
    toHaveDateBefore(memberName, date): void;
    toHaveEmptyArray(memberName): void;
    toHaveEmptyObject(memberName): void;
    toHaveEmptyString(memberName): void;
    toHaveEvenNumber(memberName): void;
    toHaveFalse(memberName): void;
    toHaveHtmlString(memberName): void;
    toHaveIso8601(memberName): void;
    toHaveJsonString(memberName): void;
    toHaveMember(memberName): void;
    toHaveMethod(memberName): void;
    toHaveNonEmptyArray(memberName): void;
    toHaveNonEmptyObject(memberName): void;
    toHaveNonEmptyString(memberName): void;
    toHaveNumber(memberName): void;
    toHaveNumberWithinRange(memberName, floor, ceiling): void;
    toHaveObject(memberName): void;
    toHaveOddNumber(memberName): void;
    toHaveString(memberName): void;
    toHaveStringLongerThan(memberName: keyof T, string): void;
    toHaveStringSameLengthAs(memberName: keyof T, string): void;
    toHaveStringShorterThan(memberName: keyof T, string): void;
    toHaveTrue(memberName: keyof T): void;
    toHaveUndefined(memberName: keyof T): void;
    toHaveWhitespaceString(memberName: keyof T): void;
    toHaveWholeNumber(memberName: keyof T): void;
    toBeRegExp(): void;
    toBeEmptyString(): void;
    toBeHtmlString(): void;
    toBeIso8601(): void;
    toBeJsonString(): void;
    toBeLongerThan(otherString: string): void;
    toBeNonEmptyString(): void;
    toBeSameLengthAs(otherString: string): void;
    toBeShorterThan(otherString: string): void;
    toBeString(): void;
    toBeNumber(): void;
    toBeArray(): void;
    toBeObject(): void;
    toLength(length: number): void;
    toBeBoolean(): void;
    toBeWhitespace(): void;
    toEndWith(substring: string): void;
    toStartWith(substring: string): void;
  }

  interface Expect {
    expect<T extends any>(expect: T): corde.IMatchers<T>;
  }
}
